This section includes basic introduction to Java packaging world to people
coming from different backgrounds. Goal is to understand language of all groups
involved. If you are a Java developer coming into contact with RPM packaging for
the first time start reading xref:XFor_Devs[Java developer] section. On the
other hand if you are coming from RPM packaging background an
xref:XFor_Packagers[introduction to Java world] is probably a better starting
point.

It should be noted that especially in this section we might sacrifice
correctness for simplicity

[[XFor_Packagers]]
=== For Packagers
Java is a programming language which is usually compiled into bytecode for JVM
(Java Virtual Machine). For more details about the JVM and bytecode
specification see
link:http://docs.oracle.com/javase/specs/jvms/se7/html/index.html[JVM
documentation]. Resulting bytecode is then assembled into zip files with
specific layout and additional metadata. Most commonly these special zip files
have `.jar` suffix, but other variations exist. These files have their format
specified in the
link:http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html[JAR File
Specification].


==== Example Java Project
To better illustrate various parts of Java packaging we will dissect simple Java
hello world application. Java sources are usually organized using directory
hierarchies. Shared directory hierarchy creates a namespace called `package` in
Java terminology. To understand naming mechanisms of Java `packages` see
link:http://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html[Java
package naming conventions].

Let's create a simple hello world application that will execute following steps
when run:

 1. Ask for a name
 2. Print out "Hello World from $name" where $name is from step one

To illustrate certain points we artificially complicate things by creating:

 - Input class used only for input of text from terminal
 - Output class used only for output on terminal
 - HelloWorldApp class used as main application

.Directory listing of example project
[source,shell]
------
$ find .
.
./Makefile
./src
./src/org
./src/org/fedoraproject
./src/org/fedoraproject/helloworld
./src/org/fedoraproject/helloworld/output
./src/org/fedoraproject/helloworld/output/Output.java
./src/org/fedoraproject/helloworld/input
./src/org/fedoraproject/helloworld/input/Input.java
./src/org/fedoraproject/helloworld/HelloWorld.java
------

In this project all packages are under `src/` directory hierarchy.

.HelloWorld.java listing
[source,java]
------
include::java_project/src/org/fedoraproject/helloworld/HelloWorld.java[]
------



.Java Namespaces
[source,shell]
------
org/fedoraproject/helloworld/input/Input.java
org/fedoraproject/helloworld/output/Output.java
org/fedoraproject/helloworld/HelloWorld.java
------

Above example makes use of three separate namespaces:

 - org.fedoraproject.helloworld.input
 - org.fedoraproject.helloworld.output
 - org.fedoraproject.helloworld

Environment setup consists of two main parts:

 - Telling JVM which Java class contains `main()` function
 - Adding required JAR files on JVM classpath

Classic compiled applications use dynamic linker to find dependencies (linked
libraries), Python interpreter has predefined directories where it searches for
imported modules. JVM itself has no embedded knowledge of installation paths and
thus no automatic way to resolve dependencies of Java projects. This means that
all Java applications have to use wrapper shell scripts to setup the environment
before invoking the JVM and running the application itself. Note that this is
not necessary for libraries.



// JVM, classpaths, imports, POM files, JAR files


[[XFor_Devs]]
=== For Java Developers
Developers!
