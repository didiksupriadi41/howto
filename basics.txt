This section includes basic introduction to Java packaging world to people
coming from different backgrounds. Goal is to understand language of all groups
involved. If you are a Java developer coming into contact with RPM packaging for
the first time start reading xref:XFor_Devs[Java developer] section. On the
other hand if you are coming from RPM packaging background an
xref:XFor_Packagers[introduction to Java world] is probably a better starting
point.

It should be noted that especially in this section we might sacrifice
correctness for simplicity

[[XFor_Packagers]]
=== For Packagers
Java is a programming language which is usually compiled into bytecode for JVM
(Java Virtual Machine). For more details about the JVM and bytecode
specification see
link:http://docs.oracle.com/javase/specs/jvms/se7/html/index.html[JVM
documentation]. Resulting bytecode is then assembled into zip files with
specific layout and additional metadata. Most commonly these special zip files
have `.jar` suffix, but other variations exist. These files have their format
specified in the
link:http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html[JAR File
Specification].


==== Example Java Project
To better illustrate various parts of Java packaging we will dissect simple Java
hello world application. Java sources are usually organized using directory
hierarchies. Shared directory hierarchy creates a namespace called `package` in
Java terminology. To understand naming mechanisms of Java `packages` see
link:http://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html[Java
package naming conventions].

Let's create a simple hello world application that will execute following steps
when run:

 1. Ask for a name
 2. Print out "Hello World from $name" where $name is from step one

To illustrate certain points we artificially complicate things by creating:

 - Input class used only for input of text from terminal
 - Output class used only for output on terminal
 - HelloWorldApp class used as main application

.Directory listing of example project
[source,shell]
------
$ find .
.
./Makefile
./src
./src/org
./src/org/fedoraproject
./src/org/fedoraproject/helloworld
./src/org/fedoraproject/helloworld/output
./src/org/fedoraproject/helloworld/output/Output.java
./src/org/fedoraproject/helloworld/input
./src/org/fedoraproject/helloworld/input/Input.java
./src/org/fedoraproject/helloworld/HelloWorld.java
------

In this project all packages are under `src/` directory hierarchy.

.HelloWorld.java listing
[source,java]
------
include::java_project/src/org/fedoraproject/helloworld/HelloWorld.java[]
------



.Java Namespaces
[source,shell]
------
org/fedoraproject/helloworld/input/Input.java
org/fedoraproject/helloworld/output/Output.java
org/fedoraproject/helloworld/HelloWorld.java
------

Above example makes use of three separate namespaces:

 - org.fedoraproject.helloworld.input
 - org.fedoraproject.helloworld.output
 - org.fedoraproject.helloworld

Environment setup consists of two main parts:

 - Telling JVM which Java class contains `main()` function
 - Adding required JAR files on JVM classpath

Classic compiled applications use dynamic linker to find dependencies (linked
libraries), Python interpreter has predefined directories where it searches for
imported modules. JVM itself has no embedded knowledge of installation paths and
thus no automatic way to resolve dependencies of Java projects. This means that
all Java applications have to use wrapper shell scripts to setup the environment
before invoking the JVM and running the application itself. Note that this is
not necessary for libraries.



// JVM, classpaths, imports, POM files, JAR files


[[XFor_Devs]]
=== For Java Developers
Packaging Java software has specifics which we will try to cover in this section
aimed at Java developers who are already familiar with Java language, JVM,
classpath handling, Maven, pom.xml file structure and dependencies.

Instead we will focus on basic packaging tools and relationships between Java
and RPM world. One of the most important questions is: What is the reason to
package software in RPM (or other distribution-specific formats). There are
several reasons for it, among others:

  - Unified way of installation of software for users of distribution regardless
    of upstream projects
  - Verification of authenticity of software packages by signing them
  - Simplified software updates
  - Automatic handling of dependencies for users
  - Common filesystem layout across distribution enforced by packaging standards
  - Ability to administer, monitor and query packages installed on several
    machines through unified interfaces
  - Distribution of additional metadata with the software itself such as
    licenses used, homepage for the project, changelogs and other information
    that users or administrators can find useful

==== Example RPM Project
RPM uses `spec` files as recipes for building software packages. A simple
example of such spec file is below.

[source,spec,numbered]
------
include::rpm_project/minimal.spec[]
------

RPM `spec` files contain several basic sections:

   * header containing package metadata
   * %prep section used for source unpacking, patching and steps to prepare for
     building
   * %build section containing compilation instructions such as Maven or Ant
     invocation
   * %install section used to preparing filesystem layout inside directory
   * %files section containing list of files to be included in the binary RPM itself
   * %changelog containing RPM changelog with prescribed format used mostly to
     document changes to spec file (not upstream)

To build RPM from link:rpm_project/minimal.spec[this `spec` file] save it in
your current directory and run `rpmbuild`:
[source,shell]
------
$ rpmbuild -bb minimal.spec
------

If everything worked OK, this should produce RPM file
`~/rpmbuild/RPMS/x86_64/minimal-1.0-1.fc18.x86_64.rpm`. You can use `rpm` or
`yum` commands to install this package and it will add `/bin/minimalistic` shell
script to your system. Above `spec` file doesn't specify any build or runtime
dependencies and lacks several other common parts for simplification.
[NOTE]
======
Paths and filenames might be slightly different depending on your architecture
and distribution. Output of the commands will tell you exact paths
======

As you can see to build RPM files you can use `rpmbuild` command. It has several
other options, which we will cover later on.

One of the most important RPM features is already mentioned handling of
dependencies. There are two types of dependencies in RPM:

  - build time dependencies (BuildRequires tag in `spec` file)
  - runtime dependencies (Requires tag in `spec` file)


==== Quiz for Java Developers
